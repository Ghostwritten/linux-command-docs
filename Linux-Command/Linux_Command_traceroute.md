#  Linux Command traceroute 路由追踪
tags: 网络, 分析

## 1. 介绍
Traceroute是Linux和Mac OS等系统默认提供的路由追踪小程序，Tracert是Windows系统默认提供的路由追踪小程序。二者的功能相同，都能探测数据包从源地址到目的地址经过的路由器的IP地址。Traceroute/Tracert的实现都借助了TTL：通过向目的地址发送一系列的探测包，设置探测包的TTL初始值分别为1,2,3…，根据返回的超时通知（ICMP Time Exceeded Message）得到源地址与目的地址之间的每一跳路由信息。虽然两者输出结果一致，但在实现原理上还有着显著的差别。


## 2. 工作原理：

Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器...... traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？

Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。

Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。

 原理过程
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200526235329146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpeGloYWhhbGVsZWhlaGU=,size_16,color_FFFFFF,t_70)

 - 从源地址发出一个UDP探测包到目的地址，并将TTL设置为1；

 - 到达路由器时，将TTL减1；

 - 当TTL变为0时，包被丢弃，路由器向源地址发回一个ICMP超时通知（ICMP Time Exceeded Message），内含发送IP包的源地址，IP包的所有内容及路由器的IP地址；

 - 当源地址收到该ICMP包时，显示这一跳路由信息；

 - 重复1～5，并每次设置TTL加1；

 - 直至目标地址收到探测数据包，并返回端口不可达通知（ICMP Port Unreachable）；

 - 当源地址收到ICMP Port Unreachable包时停止traceroute。

**注意：**

1. Linux和Mac OS等系统使用UDP包进行探测，目标端口号默认为33434，每次探测目标端口号加1。Traceroute故意使用了一个大于 30000 的目标端口号，以保证目标地址收到数据包后能够返回一个“端口不可达”的 ICMP 报文，于是源地址就可将端口不可达报文当作跟踪结束的标志。

2. Traceroute每跳默认发送3个探测包（发包的数量可通过-q进行设置），探测包的返回会受到网络情况的影响。如果防火墙封掉了ICMP的返回信息，那么相应的延时位置会以*显示。如果某台网关阻塞或者某台DNS出现问题，那么相应行的延时会变长。可以加-n 参数来避免DNS解析，以IP格式输出数据。

3. 每个探测包都有唯一的标识号，使得Traceroute能够识别返回的包。UDP数据包使用递增的目标端口号进行标识。

在大多数情况下，我们会在linux主机系统下，直接执行命令行：

```bash
traceroute hostname
```

而在Windows系统下是执行tracert的命令：

```bash
tracert hostname
```
## 3. 命令格式：

```bash
traceroute[参数][主机]
```
## 4. 命令功能：

traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。

具体参数格式：

```bash
traceroute [-dFlnrvx][-f<存活数值>][-g<网关>...][-i<网络界面>][-m<存活数值>][-p<通信端口>][-s<来源地址>][-t<服务类型>][-w<超时秒数>][主机名称或IP地址][数据包大小]
```
命令参数：

```bash
-d 使用Socket层级的排错功能。

-f 设置第一个检测数据包的存活数值TTL的大小。

-F 设置勿离断位。

-g 设置来源路由网关，最多可设置8个。

-i 使用指定的网络界面送出数据包。

-I 使用ICMP回应取代UDP资料信息。

-m 设置检测数据包的最大存活数值TTL的大小。

-n 直接使用IP地址而非主机名称。

-p 设置UDP传输协议的通信端口。

-r 忽略普通的Routing Table，直接将数据包送到远端主机上。

-s 设置本地主机送出数据包的IP地址。

-t 设置检测数据包的TOS数值。

-v 详细显示指令的执行过程。

-w 设置等待远端主机回报的时间。

-x 开启或关闭数据包的正确性检验。
```
## 5. 用法
### 5.1 最常用的用法

```bash
$ traceroute www.baidu.com
traceroute to www.baidu.com (182.61.200.7), 30 hops max, 60 byte packets
 1  * OrayBox.lan (192.168.1.1)  0.353 ms *
 2  10.0.11.254 (10.0.11.254)  0.912 ms  1.433 ms  1.627 ms
 3  124.205.26.49 (124.205.26.49)  8.052 ms  8.856 ms  9.718 ms
 4  10.255.149.185 (10.255.149.185)  3.078 ms  3.338 ms  2.789 ms
 5  10.255.36.45 (10.255.36.45)  2.948 ms  2.138 ms  2.986 ms
 6  218.241.253.77 (218.241.253.77)  1.712 ms  1.673 ms  1.402 ms
 7  14.197.177.21 (14.197.177.21)  4.934 ms 14.197.177.81 (14.197.177.81)  120.167 ms 14.197.178.49 (14.197.178.49)  1.574 ms
 8  14.197.249.126 (14.197.249.126)  2.159 ms 14.197.149.182 (14.197.149.182)  2.117 ms 14.197.249.134 (14.197.249.134)  2.342 ms
 9  182.61.252.218 (182.61.252.218)  2.938 ms 182.61.252.212 (182.61.252.212)  2.557 ms 182.61.252.220 (182.61.252.220)  2.749 ms
10  * * *
11  * * *
12  * * *
```
说明：

记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 `traceroute -q 4 www.58.com` ，表示向每个网关发送4个数据包。
如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。

### 5.2 跳数设置
显示10行
```bash
$ traceroute -m 10 www.baidu.com
traceroute to www.baidu.com (182.61.200.7), 10 hops max, 60 byte packets
 1  * * *
 2  10.0.11.254 (10.0.11.254)  1.070 ms  1.224 ms  1.520 ms
 3  124.205.26.49 (124.205.26.49)  11.125 ms  10.209 ms  11.849 ms
 4  10.255.149.185 (10.255.149.185)  2.950 ms  3.523 ms  3.185 ms
 5  10.255.36.45 (10.255.36.45)  41.992 ms  41.845 ms  43.245 ms
 6  218.241.253.77 (218.241.253.77)  1.564 ms  1.441 ms  1.369 ms
 7  14.197.243.61 (14.197.243.61)  2.921 ms 14.197.243.121 (14.197.243.121)  1.768 ms 14.197.229.169 (14.197.229.169)  1.909 ms
 8  14.197.178.106 (14.197.178.106)  11.836 ms 14.197.178.94 (14.197.178.94)  2.711 ms 14.197.249.126 (14.197.249.126)  2.306 ms
 9  182.61.252.218 (182.61.252.218)  3.604 ms 182.61.252.220 (182.61.252.220)  3.581 ms  2.858 ms
10  * * *
```
### 5.3 显示IP地址，不查主机名

```bash
$ traceroute -n www.baidu.com
traceroute -n www.baidu.com
traceroute to www.baidu.com (182.61.200.6), 30 hops max, 60 byte packets
 1  192.168.1.1  0.354 ms * *
 2  10.0.11.254  0.967 ms  1.647 ms  1.816 ms
 3  124.205.26.49  7.449 ms  9.085 ms  8.119 ms
 4  10.255.149.185  3.085 ms  2.802 ms  3.335 ms
 5  * * 10.255.36.45  3.151 ms
 6  124.205.98.1  1.459 ms  1.615 ms  1.509 ms
 7  14.197.178.41  1.749 ms 14.197.179.69  1.627 ms 14.197.177.21  1.639 ms
 8  14.197.249.94  2.123 ms 14.197.249.134  2.334 ms 14.197.249.122  1.969 ms
 9  182.61.252.212  2.445 ms  2.555 ms 182.61.252.218  4.362 ms
10  * * *
```
### 5.4 探测包使用的基本UDP端口设置6888

```bash
$ traceroute -p 6888 www.baidu.com
traceroute to www.baidu.com (182.61.200.7), 30 hops max, 60 byte packets
 1  * * *
 2  10.0.11.254 (10.0.11.254)  0.894 ms  1.404 ms  1.583 ms
 3  124.205.26.49 (124.205.26.49)  9.939 ms  13.234 ms  10.687 ms
 4  10.255.149.185 (10.255.149.185)  2.609 ms  3.058 ms  3.281 ms
 5  10.255.36.45 (10.255.36.45)  1.611 ms  4.104 ms  3.851 ms
 6  218.241.253.77 (218.241.253.77)  1.464 ms  1.420 ms  1.332 ms
 7  14.197.243.125 (14.197.243.125)  1.525 ms 14.197.177.9 (14.197.177.9)  11.018 ms 14.197.177.21 (14.197.177.21)  1.720 ms
 8  14.197.250.170 (14.197.250.170)  2.287 ms 14.197.178.94 (14.197.178.94)  2.403 ms 14.197.149.182 (14.197.149.182)  2.402 ms
 9  182.61.252.218 (182.61.252.218)  2.567 ms 182.61.252.210 (182.61.252.210)  2.528 ms 182.61.252.218 (182.61.252.218)  2.427 ms
10  * * *
```
### 5.5 把探测包的个数设置为值4

```bash
$ traceroute -q 4 www.baidu.com
traceroute to www.baidu.com (182.61.200.6), 30 hops max, 60 byte packets
 1  * * * *
 2  10.0.11.254 (10.0.11.254)  1.471 ms  1.779 ms  0.812 ms  1.934 ms
 3  124.205.26.49 (124.205.26.49)  15.320 ms  13.738 ms  14.399 ms  16.247 ms
 4  10.255.149.185 (10.255.149.185)  3.591 ms  3.831 ms  3.195 ms  4.109 ms
 5  10.255.36.45 (10.255.36.45)  3.697 ms * *  2.735 ms
 6  124.205.98.1 (124.205.98.1)  2.260 ms  2.087 ms  2.273 ms  2.058 ms
 7  14.197.179.73 (14.197.179.73)  1.630 ms 14.197.177.9 (14.197.177.9)  9.499 ms 14.197.177.81 (14.197.177.81)  66.843 ms 14.197.178.45 (14.197.178.45)  3.344 ms
 8  14.197.149.178 (14.197.149.178)  3.324 ms 14.197.249.126 (14.197.249.126)  2.112 ms 14.197.149.182 (14.197.149.182)  2.139 ms 14.197.178.98 (14.197.178.98)  2.108 ms
 9  182.61.252.220 (182.61.252.220)  2.562 ms 182.61.252.212 (182.61.252.212)  2.430 ms 182.61.252.218 (182.61.252.218)  2.464 ms  2.579 ms
10  * * * *
```
### 5.6 把对外发探测包的等待响应时间设置为3秒

```bash
$ traceroute -w 3 www.baidu.com
traceroute to www.baidu.com (182.61.200.7), 30 hops max, 60 byte packets
 1  OrayBox.lan (192.168.1.1)  0.456 ms  0.376 ms *
 2  10.0.11.254 (10.0.11.254)  1.532 ms  0.951 ms  1.968 ms
 3  124.205.26.49 (124.205.26.49)  71.877 ms  73.608 ms  72.690 ms
 4  10.255.149.185 (10.255.149.185)  3.039 ms  2.668 ms  3.273 ms
 5  10.255.36.45 (10.255.36.45)  7.212 ms  6.999 ms  7.247 ms
 6  218.241.253.77 (218.241.253.77)  1.966 ms  1.840 ms  1.778 ms
 7  14.197.178.49 (14.197.178.49)  2.409 ms 14.197.177.5 (14.197.177.5)  1.539 ms 14.197.177.89 (14.197.177.89)  1.724 ms
 8  14.197.249.94 (14.197.249.94)  2.540 ms 14.197.178.106 (14.197.178.106)  2.493 ms 14.197.249.122 (14.197.249.122)  1.981 ms
 9  182.61.252.210 (182.61.252.210)  7.632 ms 182.61.252.212 (182.61.252.212)  7.551 ms 182.61.252.210 (182.61.252.210)  7.527 ms
10  * * *
```
## 6. 总结
[深度追踪针对GitHub的DDoS攻击](https://www.freebuf.com/news/topnews/63148.html)
一些注意点
并不是所有网关都会如实返回ICMP超时报文。出于安全性考虑，大多数防火墙以及启用了防火墙功能的路由器缺省配置为不返回各种ICMP报文，其余路由器或交换机也可能被管理员主动修改配置变为不返回 ICMP报文。因此traceroute程序不一定能拿到所有的沿途网关地址。所以，当某个TTL值的数据包得不到响应时，并不能停止这一追踪过程，程序仍然会把TTL递增而发出下一个数据包。这个过程将一直持续到数据包发送到目标主机，或者达到默认或用参数指定的追踪限制（maximum_hops）才结束追踪。依据上述原理，利用了UDP数据包的traceroute程序在数据包到达真正的目的主机时，就可能因为该主机没有提供UDP服务而简单将数据包抛弃，并不返回任何信息。为了解决这个问题，traceroute故意使用了一个大于30000的端口号，因UDP协议规定端口号必须小于30000，所以目标主机收到数据包后唯一能做的事就是返回一个“端口不可达”的ICMP报文，于是主叫方就将端口不可达报文当作跟踪结束的标志。
使用UDP的traceroute，失败还是比较常见的。这常常是由于，在运营商的路由器上，UDP与ICMP的待遇大不相同。为了利于troubleshooting，ICMP ECHO Request/Reply 是不会封的，而UDP则不同。UDP常被用来做网络攻击，因为UDP无需连接，因而没有任何状态约束它，比较方便攻击者伪造源IP、伪造目的端口发送任意多的UDP包，长度自定义。所以运营商为安全考虑，对于UDP端口常常采用白名单ACL，就是只有ACL允许的端口才可以通过，没有明确允许的则统统丢弃。比如允许DNS/DHCP/SNMP等。
总结一下，traceroute主要利用IP数据包的TTL字段值 + ICMP来实现，它发送的用于探测网络路径的数据包的IP之上的协议可以是 UDP、TCP或ICMP。不同模式下，探测过程中设计的数据包如下：
UDP模式：UDP探测数据包（目标端口大于30000） + 中间网关发回 ICMP TTL 超时数据包 + 目标主机发回ICMP Destination Unreachable 数据包
TCP模式：TCP [SYN]探测数据包（目标端口为Web服务的80） + 中间网关发回 ICMP TTL 超时数据包 + 目标主机发回TCP [SYN ACK] 数据包
ICMP模式：ICMP Echo (ping) Request 探测数据包 + 中间网关发回ICMP TTL超时数据包 + 目标主机发回ICMP Echo (ping) reply 数据包
traceroute出现*的分析：源发出ICMP Request，第一个request的TTL为1，第二个request的TTL为2，以后依此递增直至第30个；中间的router送回ICMP TTL-expired ( ICMP type 11) 通知source，（packet同时因TTL超时而被drop)，由此source知晓一路上经过的每一个router；最后的destination送回ICMP Echo Reply（最后一跳不会再回ICMP TTL-expired）。所以中间任何一个router上如果封了ICMP Echo Request, traceroute就不能工作；如果封了type 11(TTL-expired), 中间的router全看不到，但能看到packet到达了最后的destination；如果封了ICMP Echo Reply，中间的全能看到，最后的destination看不到。

